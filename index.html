<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ ‚Äî —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .calculator {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        select, input {
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }
        select {
            width: 100%;
        }
        .mode-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .mode-label {
            font-weight: bold;
            color: #7f8c8d;
            transition: color 0.2s;
        }
        .mode-label.active {
            color: #2c3e50;
            text-decoration: underline;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .2s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .2s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #3498db;
        }
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        .day-length-field {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 15px;
        }
        .day-length-field input {
            width: 70px;
            text-align: center;
        }
        .rate-fields {
            margin-top: 15px;
        }
        .hidden {
            display: none;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
        }
        button:hover {
            background: #2980b9;
        }
        .results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px;
            text-align: left;
        }
        th {
            background: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .emoji, td img { image-rendering: pixelated; }
        .primary {
            background-color: #e8f5e8;
        }
        .intermediate {
            background-color: #fff3e0;
        }
        .note {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 10px;
            text-align: center;
        }
        .day-info {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .total-row {
            font-weight: bold;
            background-color: #d5e8d5;
        }
        .recipe-cell {
            font-size: 0.85em;
            color: #555;
        }
        #graph-container {
            width: 100%;
            height: 600px;
            border: 2px solid #3498db;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
            background: #ecf0f1;
            position: relative;
            cursor: grab;
        }
        #graph-container.dragging-bg {
            cursor: grabbing;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .graph-controls {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .graph-controls-left {
            display: flex;
            gap: 10px;
        }
        .graph-controls-right {
            display: flex;
            gap: 10px;
        }
        .graph-controls button, .graph-controls a {
            padding: 5px 15px;
            font-size: 14px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            line-height: normal;
            display: inline-block;
        }
        .graph-controls a:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <h1>üè≠ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞</h1>
    <div class="calculator">
        <div class="form-group">
            <label for="product">–¶–µ–ª–µ–≤–æ–π –ø—Ä–æ–¥—É–∫—Ç:</label>
            <select id="product" size="10" style="height: auto;">
                <!-- –ó–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å–∫—Ä–∏–ø—Ç–æ–º -->
            </select>
        </div>

        <div class="mode-switch">
            <span id="modePerMinuteLabel" class="mode-label active">–í –º–∏–Ω—É—Ç—É</span>
            <label class="switch">
                <input type="checkbox" id="modeToggle">
                <span class="slider"></span>
            </label>
            <span id="modePerDayLabel" class="mode-label">–ó–∞ —Å—É—Ç–∫–∏</span>
            <div class="day-length-field">
                <span>üåô —Å—É—Ç–∫–∏ =</span>
                <input type="number" id="dayLength" min="13" max="30" step="1" value="16">
                <span>–º–∏–Ω</span>
            </div>
        </div>

        <div id="rateFields" class="rate-fields">
            <div id="perMinuteField">
                <label for="ratePerMinute">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –º–∏–Ω—É—Ç—É:</label>
                <input type="number" id="ratePerMinute" min="0.1" step="0.1" value="1">
            </div>
            <div id="perDayField" class="hidden">
                <label for="ratePerDay">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞ —Å—É—Ç–∫–∏:</label>
                <input type="number" id="ratePerDay" min="0.1" step="0.1" value="10">
            </div>
        </div>

        <button id="calculate">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
    </div>

    <div class="results" id="results">
        <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div id="output">
            <p>–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–¥—É–∫—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å".</p>
        </div>

        <div id="graph-container">
            <canvas id="graph-canvas" width="2000" height="2000"></canvas>
        </div>
        <div class="graph-controls">
            <div class="graph-controls-left">
                <a href="https://github.com/Arxxon/River-Town-Factory-calculator/tree/main" target="_blank">—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π</a>
            </div>
            <div class="graph-controls-right">
                <button id="reset-graph">–°–±—Ä–æ—Å–∏—Ç—å –ø–æ–∑–∏—Ü–∏–∏ —É–∑–ª–æ–≤</button>
                <button id="reset-view">–í–æ–∑–≤—Ä–∞—Ç –≤ –¶–µ–Ω—Ç—Ä</button>
            </div>
        </div>
    </div>

    <script>
        const buildingPower = {
            "–§–∞–±—Ä–∏–∫–∞": 4,
            "–ê—Å—Å–µ–º–±–ª–µ—Ä": 18,
            "–ü–ª–∞–≤–∏–ª–∫–∞": 5,
            "–ó–∞—Ä—è–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ": 20,
            "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫": 8,
            "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä": 20,
            "–õ–∏—Ç–µ–π–Ω—ã–π —Ü–µ—Ö": 16
        };

        const recipes = [
            { product: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", output: 1, time: 2.4, ingredients: [{ item: "–¥–µ—Ä–µ–≤–æ", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–ø–∞–ª–∫–∏", output: 3, time: 4.8, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", output: 1, time: 4.8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 4 }, { item: "–±–æ–ª—Ç—ã", quantity: 6 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", output: 1, time: 2.4, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }], building: "–ü–ª–∞–≤–∏–ª–∫–∞" },
            { product: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", output: 3, time: 4.8, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–±–æ–ª—Ç—ã", output: 3, time: 1.6, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞", output: 1, time: 2.4, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∫–∞–º–µ–Ω—å", output: 1, time: 2.4, ingredients: [{ item: "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∫–∞–º–µ–Ω–Ω—ã–π –∫–∏—Ä–ø–∏—á", output: 1, time: 4.8, ingredients: [{ item: "–∫–∞–º–µ–Ω—å", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 2.4, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", output: 1, time: 2.4, ingredients: [{ item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω—ã–π –∫–∞–±–µ–ª—å", output: 3, time: 4.8, ingredients: [{ item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ", output: 3, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤–æ", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–Ω–∏—Ç—å", output: 1, time: 4.8, ingredients: [{ item: "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Ç–∫–∞–Ω—å", output: 1, time: 4.8, ingredients: [{ item: "–Ω–∏—Ç—å", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–±—É–º–∞–≥–∞", output: 2, time: 2.4, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞", output: 1, time: 4.8, ingredients: [{ item: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", output: 2, time: 9.6, ingredients: [{ item: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", quantity: 3 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", output: 1, time: 2.4, ingredients: [{ item: "–º–µ–¥–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }], building: "–ü–ª–∞–≤–∏–ª–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", output: 1, time: 3.2, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }, { item: "—É–≥–æ–ª—å", quantity: 2 }], building: "–õ–∏—Ç–µ–π–Ω—ã–π —Ü–µ—Ö" },
            { product: "–∑–æ–Ω—Ç–∏–∫", output: 1, time: 4.8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 2 }, { item: "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–±—Ä–æ–Ω–∑–æ–≤–æ–µ –∑–µ—Ä–∫–∞–ª–æ", output: 1, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", quantity: 1 }, { item: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", output: 1, time: 8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 2 }, { item: "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞", output: 1, time: 7.2, ingredients: [{ item: "–±—É–º–∞–≥–∞", quantity: 3 }, { item: "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä–∞–º–∞", output: 1, time: 4.8, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", quantity: 4 }, { item: "–±–æ–ª—Ç—ã", quantity: 6 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 4.8, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", quantity: 2 }, { item: "–±–æ–ª—Ç—ã", quantity: 4 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ", output: 1, time: 8, ingredients: [{ item: "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", quantity: 1 }, { item: "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—É—Å–∏–ª–µ–Ω–Ω–∞—è –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞", quantity: 2 }, { item: "–∫–∞–º–µ–Ω—å", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°", output: 1, time: 16, ingredients: [{ item: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", quantity: 3 }, { item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", quantity: 1 }], building: "–ó–∞—Ä—è–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ" },
            { product: "–∫—Ä–∞—Å–Ω–∞—è –∫–æ–ª–±–∞", output: 1, time: 4.8, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 3 }, { item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 3 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "–∑–µ–ª–µ–Ω–∞—è –∫–æ–ª–±–∞", output: 1, time: 8, ingredients: [{ item: "—Ç–∫–∞–Ω—å", quantity: 3 }, { item: "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", quantity: 2 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "—Å–∏–Ω—è—è –∫–æ–ª–±–∞", output: 1, time: 9.6, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ", quantity: 1 }, { item: "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞", quantity: 3 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ", output: 1, time: 12, ingredients: [{ item: "–∑–µ—Ä–Ω–æ", quantity: 4 }], building: "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫" },
            { product: "—Å–ø–∏—Ä—Ç–Ω—ã–µ –Ω–∞–ø–∏—Ç–∫–∏", output: 1, time: 12, ingredients: [{ item: "–∑–µ—Ä–Ω–æ", quantity: 4 }], building: "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫" }
        ];

        const recipeMap = new Map();
        recipes.forEach(r => recipeMap.set(r.product, r));
        const allProducts = recipes.map(r => r.product).sort();

                const iconMap = {
            "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/reinforced_iron_plate.png",
            "–±–æ–ª—Ç—ã": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/screws.png",
            "–±—Ä–æ–Ω–∑–æ–≤–æ–µ –∑–µ—Ä–∫–∞–ª–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/bronze_mirror.png",
            "–±—É–º–∞–≥–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/paper.png",
            "–¥–µ—Ä–µ–≤–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/wood.png",
            "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/wooden_plank.png",
            "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/wooden_frame.png",
            "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/wood_fiber.png",
            "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_plate.png",
            "–∂–µ–ª–µ–∑–Ω–∞—è —Ä–∞–º–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_frame.png",
            "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_ore.png",
            "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_core.png",
            "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_rod.png",
            "–∑–µ–ª–µ–Ω–∞—è –∫–æ–ª–±–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/green_flask.png",
            "–∑–µ—Ä–Ω–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/grain.png",
            "–∑–æ–Ω—Ç–∏–∫": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/umbrella.png",
            "–∫–∞–º–µ–Ω–Ω—ã–π –∫–∏—Ä–ø–∏—á": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/stone_brick.png",
            "–∫–∞–º–µ–Ω—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/stone.png",
            "–∫—Ä–∞—Å–Ω–∞—è –∫–æ–ª–±–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/red_flask.png",
            "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/cooking_oil.png",
            "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/lumber.png",
            "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/copper_plate.png",
            "–º–µ–¥–Ω–∞—è —Ä—É–¥–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/copper_ore.png",
            "–º–µ–¥–Ω—ã–π –∫–∞–±–µ–ª—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/copper_cable.png",
            "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/copper_ingot.png",
            "–Ω–∏—Ç—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/thread.png",
            "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/basic_tools.png",
            "–ø–∞–ª–∫–∏": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/sticks.png",
            "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/raw_stone.png",
            "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/oiled_paper.png",
            "—Å–∏–Ω—è—è –∫–æ–ª–±–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/blue_flask.png",
            "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/iron_ingot.png",
            "—Å–ø–∏—Ä—Ç–Ω—ã–µ –Ω–∞–ø–∏—Ç–∫–∏": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/spirits.png",
            "—Å—Ç–∞–ª—å–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/steel_plate.png",
            "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/steel_pipe.png",
            "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/steel_ingot.png",
            "—Ç–∫–∞–Ω—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/fabric.png",
            "—É–≥–æ–ª—å": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/coal.png",
            "—É—Å–∏–ª–µ–Ω–Ω–∞—è –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –ø–ª–∏—Ç–∞": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/reinforced_wooden_plate.png",
            "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°": "https://raw.githubusercontent.com/Arxxon/River-Town-Factory-calculator/main/picture/energy_module_c.png",
        };

        // Preload icons for canvas
        const iconImages = {};
        function getIconImage(nodeId) {
            if (iconImages[nodeId]) return iconImages[nodeId];
            const src = iconMap[nodeId];
            if (!src) return null;
            const img = new Image();
            img.src = src;
            img.onload = () => drawGraph();
            iconImages[nodeId] = img;
            return img;
        }

        const selectEl = document.getElementById('product');
        allProducts.forEach(prod => {
            const option = document.createElement('option');
            option.value = prod;
            option.textContent = prod;
            selectEl.appendChild(option);
        });

        const modeToggle = document.getElementById('modeToggle');
        const modePerMinuteLabel = document.getElementById('modePerMinuteLabel');
        const modePerDayLabel = document.getElementById('modePerDayLabel');
        const perMinuteField = document.getElementById('perMinuteField');
        const perDayField = document.getElementById('perDayField');
        const dayLengthInput = document.getElementById('dayLength');
        const ratePerMinute = document.getElementById('ratePerMinute');
        const ratePerDay = document.getElementById('ratePerDay');

        let currentDayLength = parseFloat(dayLengthInput.value);

        function updateMode() {
            const isDayMode = modeToggle.checked;
            if (isDayMode) {
                modePerMinuteLabel.classList.remove('active');
                modePerDayLabel.classList.add('active');
                perMinuteField.classList.add('hidden');
                perDayField.classList.remove('hidden');
            } else {
                modePerMinuteLabel.classList.add('active');
                modePerDayLabel.classList.remove('active');
                perMinuteField.classList.remove('hidden');
                perDayField.classList.add('hidden');
            }
        }

        modeToggle.addEventListener('change', updateMode);
        dayLengthInput.addEventListener('input', function() {
            let val = parseFloat(this.value);
            if (isNaN(val)) val = 16;
            if (val < 13) val = 13;
            if (val > 30) val = 30;
            this.value = val;
            currentDayLength = val;
        });

        updateMode();

        function calculate(targetProduct, targetRate) {
            const demands = {};
            const edgesMap = {};

            function addDemand(product, rate) {
                demands[product] = (demands[product] || 0) + rate;

                if (!recipeMap.has(product)) return;

                const recipe = recipeMap.get(product);
                const cyclesPerMin = rate / recipe.output;

                for (const ing of recipe.ingredients) {
                    const required = cyclesPerMin * ing.quantity;
                    if (required <= 0) continue;

                    const key = `${ing.item}|${product}`;
                    edgesMap[key] = (edgesMap[key] || 0) + required;

                    addDemand(ing.item, required);
                }
            }

            addDemand(targetProduct, targetRate);

            const edges = Object.entries(edgesMap).map(([key, quantity]) => {
                const [from, to] = key.split('|');
                return { from, to, quantity };
            });

            const machines = {};
            const primary = {};

            for (const [prod, rate] of Object.entries(demands)) {
                if (recipeMap.has(prod)) {
                    const recipe = recipeMap.get(prod);
                    const cyclesPerMin = rate / recipe.output;
                    const timeMin = recipe.time / 60;
                    machines[prod] = cyclesPerMin * timeMin;
                } else {
                    primary[prod] = rate;
                }
            }

            return { demands, machines, primary, edges };
        }

        let graphNodes = [];
        let graphEdges = [];
        let graphMachines = {};
        let demandsForGraph = {};

        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;

        let draggedNodeIndex = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let isDraggingBg = false;
        let lastMouseX = 0, lastMouseY = 0;

        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('graph-container');

        const dpr = window.devicePixelRatio || 1;
        const WORLD_W = 8000;
        const WORLD_H = 8000;
        canvas.width  = WORLD_W * dpr;
        canvas.height = WORLD_H * dpr;
        canvas.style.width  = WORLD_W + 'px';
        canvas.style.height = WORLD_H + 'px';
        ctx.imageSmoothingEnabled = true;

        function canvasToWorld(canvasX, canvasY) {
            return {
                x: (canvasX - offsetX) / scale,
                y: (canvasY - offsetY) / scale
            };
        }

        function splitTitle(nodeId) {
            const fullText = nodeId;
            const maxChars = 16;

            const words = fullText.split(' ');
            const lines = [];
            let currentLine = '';

            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                let testLength = 0;
                for (let char of testLine) {
                    if (char.match(/\p{Emoji}/u)) {
                        testLength += 2;
                    } else {
                        testLength += 1;
                    }
                }
                if (testLength <= maxChars) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);

            if (lines.length === 0) lines.push(fullText);

            const titleHeight = lines.length * 24;
            const extraHeight = 8 + 16 + 16 + 16;
            const padding = 20;
            const height = titleHeight + extraHeight + padding;
            return { lines, height };
        }

        function generateInitialPositions(demands, edges) {
            const nodeList = Object.keys(demands).sort();
            const NODE_W = 180;
            const PAD_X = 120;  // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∑–∞–∑–æ—Ä –º–µ–∂–¥—É –∫–æ–ª–æ–Ω–∫–∞–º–∏
            const PAD_Y = 90;  // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∑–∞–∑–æ—Ä –º–µ–∂–¥—É —É–∑–ª–∞–º–∏

            // 1. –í—ã—á–∏—Å–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å (–∫–æ–ª–æ–Ω–∫—É) –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞
            const level = {};
            const computed = new Set();
            function computeLevel(node) {
                if (computed.has(node)) return level[node];
                if (!recipeMap.has(node)) {
                    level[node] = 0; computed.add(node); return 0;
                }
                const recipe = recipeMap.get(node);
                let maxLvl = -1;
                for (const ing of recipe.ingredients) {
                    if (demands[ing.item] !== undefined)
                        maxLvl = Math.max(maxLvl, computeLevel(ing.item));
                }
                level[node] = maxLvl + 1;
                computed.add(node);
                return level[node];
            }
            nodeList.forEach(n => computeLevel(n));

            // 2. –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É—Ä–æ–≤–Ω—è–º
            const levelMap = {};
            nodeList.forEach(n => {
                const lvl = level[n];
                if (!levelMap[lvl]) levelMap[lvl] = [];
                levelMap[lvl].push(n);
            });
            const maxLevel = Math.max(...Object.keys(levelMap).map(Number));

            // 3. Barycenter heuristic ‚Äî —Å–æ—Ä—Ç–∏—Ä—É–µ–º —É–∑–ª—ã –≤ –∫–æ–ª–æ–Ω–∫–µ –ø–æ —Å—Ä–µ–¥–Ω–µ–º—É Y —Å–æ—Å–µ–¥–µ–π –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π
            //    –î–µ–ª–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—Ö–æ–¥–æ–≤ —Ç—É–¥–∞-–æ–±—Ä–∞—Ç–Ω–æ
            const nodeHeight = {};
            nodeList.forEach(n => { nodeHeight[n] = splitTitle(n).height; });

            // –ù–∞—á–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ ‚Äî –ø—Ä–æ—Å—Ç–æ –∞–ª—Ñ–∞–≤–∏—Ç–Ω—ã–π (—É–∂–µ –∑–∞–¥–∞–Ω)
            for (let pass = 0; pass < 4; pass++) {
                const forward = pass % 2 === 0;
                const lvls = forward
                    ? Array.from({length: maxLevel + 1}, (_, i) => i)
                    : Array.from({length: maxLevel + 1}, (_, i) => maxLevel - i);

                for (const lvl of lvls) {
                    if (!levelMap[lvl]) continue;
                    const refLevel = forward ? lvl - 1 : lvl + 1;
                    if (!levelMap[refLevel]) continue;

                    // –°—á–∏—Ç–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ Y —Å–æ—Å–µ–¥–µ–π (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ø–æ –∏–Ω–¥–µ–∫—Å—É)
                    const refPos = {};
                    levelMap[refLevel].forEach((n, i) => { refPos[n] = i; });

                    // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –≤ —Ç–µ–∫—É—â–µ–º —É—Ä–æ–≤–Ω–µ ‚Äî —Å—á–∏—Ç–∞–µ–º barycentre
                    const bary = {};
                    for (const node of levelMap[lvl]) {
                        const neighbors = [];
                        for (const e of edges) {
                            if (forward && e.to === node && refPos[e.from] !== undefined)
                                neighbors.push(refPos[e.from]);
                            if (!forward && e.from === node && refPos[e.to] !== undefined)
                                neighbors.push(refPos[e.to]);
                        }
                        bary[node] = neighbors.length
                            ? neighbors.reduce((a, b) => a + b, 0) / neighbors.length
                            : levelMap[lvl].indexOf(node);
                    }
                    levelMap[lvl].sort((a, b) => bary[a] - bary[b]);
                }
            }

            // 4. –í—ã—á–∏—Å–ª—è–µ–º X –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è (—à–∏—Ä–∏–Ω–∞ –∫–æ–ª–æ–Ω–∫–∏ = NODE_W)
            const sortedLevels = Object.keys(levelMap).map(Number).sort((a, b) => a - b);
            const levelX = {};
            let curX = 150;
            for (const lvl of sortedLevels) {
                levelX[lvl] = curX;
                curX += NODE_W + PAD_X;
            }

            // 5. –í—ã—á–∏—Å–ª—è–µ–º Y ‚Äî —Ä–∞—Å—Å—Ç–∞–≤–ª—è–µ–º —Å —É—á—ë—Ç–æ–º —Ä–µ–∞–ª—å–Ω–æ–π –≤—ã—Å–æ—Ç—ã + –∑–∞–∑–æ—Ä–∞
            const nodeY = {};
            for (const lvl of sortedLevels) {
                const col = levelMap[lvl];
                // –°—É–º–º–∞—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –∫–æ–ª–æ–Ω–∫–∏
                const totalH = col.reduce((s, n) => s + nodeHeight[n], 0)
                             + PAD_Y * (col.length - 1);
                let y = 300 + Math.max(0, (2000 - totalH) / 2); // —Ü–µ–Ω—Ç—Ä ~3000px –æ—Ç –≤–µ—Ä—Ö–∞
                for (const n of col) {
                    nodeY[n] = y;
                    y += nodeHeight[n] + PAD_Y;
                }
            }

            // 6. –ù–µ—Å–∫–æ–ª—å–∫–æ –∏—Ç–µ—Ä–∞—Ü–∏–π —Å–∏–ª–æ–≤–æ–≥–æ —Ä–∞—Å—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–æ–ª–æ–Ω–∫–∏
            for (let iter = 0; iter < 20; iter++) {
                for (const lvl of sortedLevels) {
                    const col = levelMap[lvl];
                    for (let i = 1; i < col.length; i++) {
                        const a = col[i - 1], b = col[i];
                        const minDist = nodeHeight[a] + PAD_Y;
                        const dist = nodeY[b] - nodeY[a];
                        if (dist < minDist) {
                            const push = (minDist - dist) / 2;
                            nodeY[a] -= push;
                            nodeY[b] += push;
                        }
                    }
                }
            }

            // 7. –°—Ç—Ä–æ–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ —É–∑–ª–æ–≤
            const nodes = [];
            for (const n of nodeList) {
                const { lines, height } = splitTitle(n);
                nodes.push({
                    id: n,
                    x: levelX[level[n]],
                    y: nodeY[n],
                    width: NODE_W,
                    height: height,
                    lines: lines
                });
            }
            return nodes;
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(dpr, dpr);
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2 / scale;
            ctx.font = `${12 / scale}px Arial`;
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –±–æ–∫—Å–æ–≤ –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–µ–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
            const edgeLabelBoxes = [];
            graphEdges.forEach(edge => {
                const fromNode = graphNodes.find(n => n.id === edge.from);
                const toNode   = graphNodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) { edgeLabelBoxes.push(null); return; }

                let label = edge.quantity.toFixed(2);
                const fromMachines = graphMachines[edge.from];
                const fromDemand   = demandsForGraph[edge.from];
                if (fromMachines !== undefined && fromDemand > 0) {
                    const allocated = fromMachines * (edge.quantity / fromDemand);
                    label += ` (‚öô ${allocated.toFixed(2)})`;
                }
                const isPrimary = !recipeMap.has(edge.from);
                const perDayLabel = isPrimary
                    ? (edge.quantity * currentDayLength).toFixed(1) + ' /—Å—É—Ç' : null;

                ctx.font = `12px Arial`;
                const tw1 = ctx.measureText(label).width;
                let bw, bh;
                if (isPrimary && perDayLabel) {
                    ctx.font = `bold 12px Arial`;
                    const tw2 = ctx.measureText(perDayLabel).width;
                    bw = Math.max(tw1, tw2) + 20; bh = 36;
                } else {
                    bw = tw1 + 16; bh = 20;
                }

                // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è ‚Äî —Å–µ—Ä–µ–¥–∏–Ω–∞ —Ä–µ–±—Ä–∞
                const fromX = fromNode.x + fromNode.width/2;
                const fromY = fromNode.y + fromNode.height/2;
                const toX   = toNode.x + toNode.width/2;
                const toY   = toNode.y + toNode.height/2;
                let cx = (fromX + toX) / 2;
                let cy = (fromY + toY) / 2;

                // –í–µ–∫—Ç–æ—Ä –≤–¥–æ–ª—å —Ä–µ–±—Ä–∞ –∏ –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä
                const dx = toX - fromX, dy = toY - fromY;
                const len = Math.sqrt(dx*dx + dy*dy) || 1;
                const nx = -dy / len, ny = dx / len; // –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä

                // –°–º–µ—â–∞–µ–º –±–æ–∫—Å —á—Ç–æ–±—ã –æ–Ω –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–ª —É–∑–ª—ã ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∏ —Å–¥–≤–∏–≥–∞–µ–º –≤–¥–æ–ª—å —Ä–µ–±—Ä–∞
                function boxOverlapsNode(bx, by, node) {
                    return bx < node.x + node.width  && bx + bw > node.x &&
                           by < node.y + node.height && by + bh > node.y;
                }

                // –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏ –∏—â–µ–º –ø–æ–∑–∏—Ü–∏—é –Ω–∞ —Ä–µ–±—Ä–µ –≥–¥–µ –±–æ–∫—Å –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç —É–∑–ª—ã
                let bestT = 0.5;
                for (let t = 0.2; t <= 0.8; t += 0.05) {
                    const tx = fromX + dx * t - bw/2;
                    const ty = fromY + dy * t - bh/2;
                    const overlap = graphNodes.some(n => boxOverlapsNode(tx, ty, n));
                    if (!overlap) { bestT = t; break; }
                }
                cx = fromX + dx * bestT;
                cy = fromY + dy * bestT;

                // –ï—Å–ª–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç ‚Äî —Å–¥–≤–∏–≥–∞–µ–º –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–æ
                let perpOffset = 0;
                const STEP = 10;
                for (let s = 0; s <= 60; s += STEP) {
                    for (const sign of [1, -1]) {
                        const off = sign * s;
                        const bx = cx - bw/2 + nx * off;
                        const by = cy - bh/2 + ny * off;
                        if (!graphNodes.some(n => boxOverlapsNode(bx, by, n))) {
                            perpOffset = off; s = 999; break;
                        }
                    }
                }
                cx += nx * perpOffset;
                cy += ny * perpOffset;

                edgeLabelBoxes.push({ cx, cy, bw, bh, label, isPrimary, perDayLabel, edge });
            });

            // –†–∞—Å—Ç–∞–ª–∫–∏–≤–∞–µ–º –±–æ–∫—Å—ã –ø–æ–¥–ø–∏—Å–µ–π –º–µ–∂–¥—É —Å–æ–±–æ–π
            for (let iter = 0; iter < 30; iter++) {
                for (let i = 0; i < edgeLabelBoxes.length; i++) {
                    for (let j = i+1; j < edgeLabelBoxes.length; j++) {
                        const a = edgeLabelBoxes[i], b = edgeLabelBoxes[j];
                        if (!a || !b) continue;
                        const ax1 = a.cx - a.bw/2, ax2 = a.cx + a.bw/2;
                        const ay1 = a.cy - a.bh/2, ay2 = a.cy + a.bh/2;
                        const bx1 = b.cx - b.bw/2, bx2 = b.cx + b.bw/2;
                        const by1 = b.cy - b.bh/2, by2 = b.cy + b.bh/2;
                        const overX = Math.min(ax2, bx2) - Math.max(ax1, bx1);
                        const overY = Math.min(ay2, by2) - Math.max(ay1, by1);
                        if (overX > 0 && overY > 0) {
                            if (overX < overY) {
                                const push = overX / 2 + 2;
                                if (a.cx < b.cx) { a.cx -= push; b.cx += push; }
                                else             { a.cx += push; b.cx -= push; }
                            } else {
                                const push = overY / 2 + 2;
                                if (a.cy < b.cy) { a.cy -= push; b.cy += push; }
                                else             { a.cy += push; b.cy -= push; }
                            }
                        }
                    }
                }
            }

            // –†–∏—Å—É–µ–º —Ä—ë–±—Ä–∞ (–ª–∏–Ω–∏–∏)
            graphEdges.forEach(edge => {
                const fromNode = graphNodes.find(n => n.id === edge.from);
                const toNode   = graphNodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;
                const fromX = fromNode.x + fromNode.width/2;
                const fromY = fromNode.y + fromNode.height/2;
                const toX   = toNode.x + toNode.width/2;
                const toY   = toNode.y + toNode.height/2;
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#7f8c8d';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();
            });

            graphNodes.forEach(node => {
                ctx.fillStyle = '#3498db';
                ctx.shadowColor = '#2c3e50';
                ctx.shadowBlur = 5 / scale;
                ctx.beginPath();
                ctx.roundRect(node.x, node.y, node.width, node.height, 20);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.font = `20px "Segoe UI", "Helvetica", "Arial", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const lines = node.lines;
                const lineHeight = 24;
                const titleHeight = lines.length * lineHeight;
                const extraHeight = 56;
                const totalContentHeight = titleHeight + extraHeight;
                const startY = node.y + (node.height - totalContentHeight) / 2;

                // Draw icon image at top of node
                const iconImg = getIconImage(node.id);
                const ICON_SIZE = 20;
                const iconX = node.x + node.width/2 - ICON_SIZE/2;
                const iconY = startY - ICON_SIZE - 4;
                if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconImg, iconX, iconY, ICON_SIZE, ICON_SIZE);
                    ctx.imageSmoothingEnabled = true;
                }

                for (let i = 0; i < lines.length; i++) {
                    ctx.fillText(lines[i], node.x + node.width/2, startY + i * lineHeight + lineHeight/2);
                }

                const rate = demandsForGraph[node.id];
                const machinesCount = graphMachines[node.id];
                if (rate !== undefined) {
                    ctx.font = `16px "Segoe UI", "Helvetica", "Arial", sans-serif`;
                    ctx.fillStyle = '#f1c40f';
                    const yellowY = startY + titleHeight + 16;
                    ctx.fillText(rate.toFixed(2) + '/min', node.x + node.width/2, yellowY);
                    if (machinesCount !== undefined) {
                        ctx.fillStyle = '#2ecc71';
                        const greenY = yellowY + 24;
                        ctx.fillText('‚öô ' + machinesCount.toFixed(2), node.x + node.width/2, greenY);
                    }
                }
            });

            // –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ —Ä–∞—Å—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–µ–π –æ—Ç —É–∑–ª–æ–≤ –ø–æ—Å–ª–µ –≤–∑–∞–∏–º–Ω–æ–≥–æ —Ä–∞—Å—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è
            for (let iter = 0; iter < 20; iter++) {
                let moved = false;
                for (const box of edgeLabelBoxes) {
                    if (!box) continue;
                    for (const node of graphNodes) {
                        const bx = box.cx - box.bw/2, by = box.cy - box.bh/2;
                        const overX = Math.min(bx + box.bw, node.x + node.width)  - Math.max(bx, node.x);
                        const overY = Math.min(by + box.bh, node.y + node.height) - Math.max(by, node.y);
                        if (overX > 0 && overY > 0) {
                            moved = true;
                            if (overX < overY) {
                                const push = overX / 2 + 2;
                                box.cx += (box.cx < node.x + node.width/2) ? -push : push;
                            } else {
                                const push = overY / 2 + 2;
                                box.cy += (box.cy < node.y + node.height/2) ? -push : push;
                            }
                        }
                    }
                }
                if (!moved) break;
            }

            // –†–∏—Å—É–µ–º –ø–æ–¥–ø–∏—Å–∏ –Ω–∞ —Ä—ë–±—Ä–∞—Ö –ø–æ–≤–µ—Ä—Ö —É–∑–ª–æ–≤
            edgeLabelBoxes.forEach(box => {
                if (!box) return;
                const { cx, cy, bw, bh, label, isPrimary, perDayLabel } = box;
                if (isPrimary && perDayLabel) {
                    ctx.fillStyle = '#fff8e1';
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.roundRect(cx - bw/2, cy - bh/2, bw, bh, 4);
                    ctx.fill(); ctx.stroke();
                    ctx.font = `12px Arial`;
                    ctx.fillStyle = '#2c3e50';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, cx, cy - 9);
                    ctx.font = `bold 12px Arial`;
                    ctx.fillStyle = '#c0392b';
                    ctx.fillText(perDayLabel, cx, cy + 9);
                } else {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#a0a0a0';
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.roundRect(cx - bw/2, cy - bh/2, bw, bh, 3);
                    ctx.fill(); ctx.stroke();
                    ctx.font = `12px Arial`;
                    ctx.fillStyle = '#2c3e50';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, cx, cy);
                }
                ctx.lineWidth = 2 / scale;
            });

            ctx.restore();
        }

        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            this.closePath();
            return this;
        };

        function centerCameraOnNodes() {
            if (graphNodes.length === 0) {
                scale = 1; offsetX = 0; offsetY = 0;
                drawGraph(); return;
            }
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const node of graphNodes) {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
            }
            const nodesW = maxX - minX;
            const nodesH = maxY - minY;
            const padding = 80;
            const cw = container.clientWidth;
            const ch = container.clientHeight;
            const scaleX = (cw - padding * 2) / nodesW;
            const scaleY = (ch - padding * 2) / nodesH;
            scale = Math.min(scaleX, scaleY, 1.5);
            scale = Math.max(scale, 0.1);
            offsetX = cw / 2 - (minX + nodesW / 2) * scale;
            offsetY = ch / 2 - (minY + nodesH / 2) * scale;
            drawGraph();
        }

        function updateGraph(edges, demands, machines) {
            demandsForGraph = demands;
            graphMachines = machines;
            graphEdges = edges;
            if (Object.keys(demands).length > 0) {
                graphNodes = generateInitialPositions(demands, edges);
                centerCameraOnNodes();
            } else {
                graphNodes = [];
                drawGraph();
            }
        }

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseCanvasX = (e.clientX - rect.left);
            const mouseCanvasY = (e.clientY - rect.top);

            const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.min(Math.max(scale * delta, 0.1), 3);

            offsetX = mouseCanvasX - worldPos.x * newScale;
            offsetY = mouseCanvasY - worldPos.y * newScale;

            scale = newScale;
            drawGraph();
        });

        container.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseCanvasX = (e.clientX - rect.left);
            const mouseCanvasY = (e.clientY - rect.top);

            let hitNode = false;
            for (let i = 0; i < graphNodes.length; i++) {
                const node = graphNodes[i];
                const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);
                if (worldPos.x >= node.x && worldPos.x <= node.x + node.width &&
                    worldPos.y >= node.y && worldPos.y <= node.y + node.height) {
                    hitNode = true;
                    draggedNodeIndex = i;
                    dragOffsetX = worldPos.x - node.x;
                    dragOffsetY = worldPos.y - node.y;
                    break;
                }
            }

            if (!hitNode) {
                isDraggingBg = true;
                lastMouseX = mouseCanvasX;
                lastMouseY = mouseCanvasY;
                container.classList.add('dragging-bg');
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (draggedNodeIndex !== null) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseCanvasX = (e.clientX - rect.left);
                const mouseCanvasY = (e.clientY - rect.top);
                const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);

                const node = graphNodes[draggedNodeIndex];
                node.x = worldPos.x - dragOffsetX;
                node.y = worldPos.y - dragOffsetY;

                node.x = Math.max(0, Math.min(WORLD_W - node.width, node.x));
                node.y = Math.max(0, Math.min(WORLD_H - node.height, node.y));

                drawGraph();
            } else if (isDraggingBg) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseCanvasX = (e.clientX - rect.left);
                const mouseCanvasY = (e.clientY - rect.top);

                const dx = mouseCanvasX - lastMouseX;
                const dy = mouseCanvasY - lastMouseY;

                offsetX += dx;
                offsetY += dy;

                lastMouseX = mouseCanvasX;
                lastMouseY = mouseCanvasY;

                drawGraph();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (draggedNodeIndex !== null) {
                draggedNodeIndex = null;
            }
            if (isDraggingBg) {
                isDraggingBg = false;
                container.classList.remove('dragging-bg');
            }
        });

        document.getElementById('reset-graph').addEventListener('click', () => {
            if (Object.keys(demandsForGraph).length > 0) {
                graphNodes = generateInitialPositions(demandsForGraph, graphEdges);
                centerCameraOnNodes();
            }
        });

        document.getElementById('reset-view').addEventListener('click', () => {
            centerCameraOnNodes();
        });

        function formatRecipe(recipe) {
            const inputs = recipe.ingredients
                .map(ing => `${ing.quantity} ${ing.item}`)
                .join(' + ');
            return `${inputs} ‚Üí ${recipe.output} —à—Ç (${recipe.time}—Å, ${recipe.building})`;
        }

        function displayResults(targetProduct, targetRate, modeDescription) {
            const result = calculate(targetProduct, targetRate);
            const { demands, machines, primary, edges } = result;

            const allProducts = Object.keys(demands).sort((a, b) => {
                const aIsPrimary = !recipeMap.has(a);
                const bIsPrimary = !recipeMap.has(b);
                if (aIsPrimary && !bIsPrimary) return 1;
                if (!aIsPrimary && bIsPrimary) return -1;
                return 0;
            });

            let html = `<div class="day-info">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—É—Ç–æ–∫: ${currentDayLength} –º–∏–Ω</div>`;
            html += `<p><strong>–†–µ–∂–∏–º:</strong> ${modeDescription}</p>`;
            html += `<table>
                <tr>
                    <th>–ü—Ä–æ–¥—É–∫—Ç</th>
                    <th>–ò–∫–æ–Ω–∫–∞</th>
                    <th>–†–µ—Ü–µ–ø—Ç</th>
                    <th>–í –º–∏–Ω—É—Ç—É</th>
                    <th>–ó–∞ —Å—É—Ç–∫–∏</th>
                    <th>–ú–∞—à–∏–Ω</th>
                    <th>–≠–Ω–µ—Ä–≥–∏—è (–∫–í—Ç)</th>
                    <th>–ó–¥–∞–Ω–∏–µ</th>
                </tr>`;

            let totalEnergy = 0;

            for (const prod of allProducts) {
                const rate = demands[prod];
                const perDay = rate * currentDayLength;
                const icon = iconMap[prod] || "";
                const isPrimary = !recipeMap.has(prod);
                const rowClass = isPrimary ? 'primary' : 'intermediate';

                let recipeCell = '‚Äî';
                let machineCell = '‚Äî';
                let energyCell = '‚Äî';
                let buildingCell = '‚Äî';

                if (!isPrimary) {
                    const recipe = recipeMap.get(prod);
                    const machineCount = machines[prod];
                    const building = recipe.building;
                    const power = buildingPower[building] || 0;
                    const energy = machineCount * power;
                    totalEnergy += energy;
                    recipeCell = formatRecipe(recipe);
                    machineCell = machineCount.toFixed(2);
                    energyCell = energy.toFixed(2) + ' –∫–í—Ç';
                    buildingCell = building;
                }

                html += `<tr class="${rowClass}">
                    <td>${prod}</td>
                    <td><img src="${icon}" style="width:28px;height:28px;image-rendering:pixelated;vertical-align:middle;"></td>
                    <td class="recipe-cell">${recipeCell}</td>
                    <td>${rate.toFixed(2)}</td>
                    <td>${perDay.toFixed(2)}</td>
                    <td>${machineCell}</td>
                    <td>${energyCell}</td>
                    <td>${buildingCell}</td>
                </tr>`;
            }

            html += `<tr class="total-row">
                <td colspan="6" style="text-align: right;"><strong>–ò—Ç–æ–≥–æ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ:</strong></td>
                <td><strong>${totalEnergy.toFixed(2)} –∫–í—Ç</strong></td>
                <td></td>
            </tr>`;
            html += `</table>`;
            html += `<p class="note">* –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∞—à–∏–Ω –∏ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ —É–∫–∞–∑–∞–Ω—ã –≤ –¥–æ–ª—è—Ö (–¥–ª—è –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã). –î–ª—è –ø–æ—Å—Ç—Ä–æ–π–∫–∏ –æ–∫—Ä—É–≥–ª–∏—Ç–µ –≤–≤–µ—Ä—Ö.</p>`;

            document.getElementById('output').innerHTML = html;

            updateGraph(edges, demands, machines);
        }

        document.getElementById('calculate').addEventListener('click', () => {
            const product = document.getElementById('product').value;
            const isDayMode = modeToggle.checked;

            let rate;
            let modeDescription;

            if (!isDayMode) {
                rate = parseFloat(ratePerMinute.value);
                if (isNaN(rate) || rate <= 0) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –º–∏–Ω—É—Ç—É.');
                    return;
                }
                modeDescription = `–≤ –º–∏–Ω—É—Ç—É: ${rate} —à—Ç/–º–∏–Ω`;
            } else {
                const amountPerDay = parseFloat(ratePerDay.value);
                if (isNaN(amountPerDay) || amountPerDay <= 0) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞ —Å—É—Ç–∫–∏.');
                    return;
                }
                rate = amountPerDay / currentDayLength;
                modeDescription = `–∑–∞ —Å—É—Ç–∫–∏ (${currentDayLength} –º–∏–Ω): ${amountPerDay} —à—Ç ‚Üí ${rate.toFixed(2)} —à—Ç/–º–∏–Ω`;
            }

            displayResults(product, rate, modeDescription);
        });

        // –ü—É—Å—Ç–æ–π —Å—Ç–∞—Ä—Ç
        updateGraph([], {}, {});
    </script>

</body>
</html>
