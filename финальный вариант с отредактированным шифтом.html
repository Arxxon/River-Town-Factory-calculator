<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ ‚Äî –∑–∞–ø–∞—Å —Å–Ω–∏–∑—É</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .calculator {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        select, input {
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }
        select {
            width: 100%;
        }
        .mode-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .mode-label {
            font-weight: bold;
            color: #7f8c8d;
            transition: color 0.2s;
        }
        .mode-label.active {
            color: #2c3e50;
            text-decoration: underline;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .2s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .2s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #3498db;
        }
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        .day-length-field {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 15px;
        }
        .day-length-field input {
            width: 70px;
            text-align: center;
        }
        .rate-fields {
            margin-top: 15px;
        }
        .hidden {
            display: none;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
        }
        button:hover {
            background: #2980b9;
        }
        .results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px;
            text-align: left;
        }
        th {
            background: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .emoji {
            font-size: 1.2em;
            margin-right: 5px;
        }
        .primary {
            background-color: #e8f5e8;
        }
        .intermediate {
            background-color: #fff3e0;
        }
        .note {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 10px;
            text-align: center;
        }
        .day-info {
            font-weight: bold;
            margin-bottom: 10px;
        }
        .total-row {
            font-weight: bold;
            background-color: #d5e8d5;
        }
        #graph-container {
            width: 100%;
            height: 600px;
            border: 2px solid #3498db;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
            background: #ecf0f1;
            position: relative;
            cursor: grab;
        }
        #graph-container.dragging-bg {
            cursor: grabbing;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .graph-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .graph-controls button {
            width: auto;
            padding: 5px 15px;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <h1>üè≠ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ (–∑–∞–ø–∞—Å —Å–Ω–∏–∑—É)</h1>
    <div class="calculator">
        <div class="form-group">
            <label for="product">–¶–µ–ª–µ–≤–æ–π –ø—Ä–æ–¥—É–∫—Ç:</label>
            <select id="product" size="10" style="height: auto;">
                <!-- –ó–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å–∫—Ä–∏–ø—Ç–æ–º -->
            </select>
        </div>

        <div class="mode-switch">
            <span id="modePerMinuteLabel" class="mode-label active">–í –º–∏–Ω—É—Ç—É</span>
            <label class="switch">
                <input type="checkbox" id="modeToggle">
                <span class="slider"></span>
            </label>
            <span id="modePerDayLabel" class="mode-label">–ó–∞ —Å—É—Ç–∫–∏</span>
            <div class="day-length-field">
                <span>üåô —Å—É—Ç–∫–∏ =</span>
                <input type="number" id="dayLength" min="13" max="30" step="1" value="16">
                <span>–º–∏–Ω</span>
            </div>
        </div>

        <div id="rateFields" class="rate-fields">
            <div id="perMinuteField">
                <label for="ratePerMinute">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –º–∏–Ω—É—Ç—É:</label>
                <input type="number" id="ratePerMinute" min="0.1" step="0.1" value="1">
            </div>
            <div id="perDayField" class="hidden">
                <label for="ratePerDay">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞ —Å—É—Ç–∫–∏:</label>
                <input type="number" id="ratePerDay" min="0.1" step="0.1" value="10">
            </div>
        </div>

        <button id="calculate">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
    </div>

    <div class="results" id="results">
        <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div id="output">
            <p>–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–¥—É–∫—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å".</p>
        </div>

        <div id="graph-container">
            <canvas id="graph-canvas" width="2000" height="2000"></canvas>
        </div>
        <div class="graph-controls">
            <button id="reset-graph">–°–±—Ä–æ—Å–∏—Ç—å –ø–æ–∑–∏—Ü–∏–∏ —É–∑–ª–æ–≤</button>
            <button id="reset-view">–°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥</button>
        </div>
    </div>

    <script>
        const buildingPower = {
            "–§–∞–±—Ä–∏–∫–∞": 4,
            "–ê—Å—Å–µ–º–±–ª–µ—Ä": 18,
            "–ü–ª–∞–≤–∏–ª–∫–∞": 5,
            "–ó–∞—Ä—è–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ": 20,
            "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫": 8,
            "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä": 20,
            "–õ–∏—Ç–µ–π–Ω—ã–π —Ü–µ—Ö": 16
        };

        const recipes = [
            { product: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", output: 1, time: 2.4, ingredients: [{ item: "–¥–µ—Ä–µ–≤–æ", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–ø–∞–ª–∫–∏", output: 3, time: 4.8, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", output: 1, time: 4.8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 4 }, { item: "–±–æ–ª—Ç—ã", quantity: 6 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", output: 1, time: 2.4, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }], building: "–ü–ª–∞–≤–∏–ª–∫–∞" },
            { product: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", output: 3, time: 4.8, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–±–æ–ª—Ç—ã", output: 3, time: 1.6, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞", output: 1, time: 2.4, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∫–∞–º–µ–Ω—å", output: 1, time: 2.4, ingredients: [{ item: "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∫–∞–º–µ–Ω–Ω—ã–π –∫–∏—Ä–ø–∏—á", output: 1, time: 4.8, ingredients: [{ item: "–∫–∞–º–µ–Ω—å", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 2.4, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", output: 1, time: 2.4, ingredients: [{ item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω—ã–π –∫–∞–±–µ–ª—å", output: 3, time: 4.8, ingredients: [{ item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ", output: 3, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤–æ", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–Ω–∏—Ç—å", output: 1, time: 4.8, ingredients: [{ item: "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Ç–∫–∞–Ω—å", output: 1, time: 4.8, ingredients: [{ item: "–Ω–∏—Ç—å", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–±—É–º–∞–≥–∞", output: 2, time: 2.4, ingredients: [{ item: "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª", quantity: 1 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞", output: 1, time: 4.8, ingredients: [{ item: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", quantity: 2 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", output: 2, time: 9.6, ingredients: [{ item: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", quantity: 3 }], building: "–§–∞–±—Ä–∏–∫–∞" },
            { product: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", output: 1, time: 2.4, ingredients: [{ item: "–º–µ–¥–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }], building: "–ü–ª–∞–≤–∏–ª–∫–∞" },
            { product: "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫", output: 1, time: 3.2, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞", quantity: 2 }, { item: "—É–≥–æ–ª—å", quantity: 2 }], building: "–õ–∏—Ç–µ–π–Ω—ã–π —Ü–µ—Ö" },
            { product: "–∑–æ–Ω—Ç–∏–∫", output: 1, time: 4.8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 2 }, { item: "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–±—Ä–æ–Ω–∑–æ–≤–æ–µ –∑–µ—Ä–∫–∞–ª–æ", output: 1, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", quantity: 1 }, { item: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", output: 1, time: 8, ingredients: [{ item: "–ø–∞–ª–∫–∏", quantity: 2 }, { item: "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞", output: 1, time: 7.2, ingredients: [{ item: "–±—É–º–∞–≥–∞", quantity: 3 }, { item: "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∂–µ–ª–µ–∑–Ω–∞—è —Ä–∞–º–∞", output: 1, time: 4.8, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å", quantity: 4 }, { item: "–±–æ–ª—Ç—ã", quantity: 6 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 4.8, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", quantity: 2 }, { item: "–±–æ–ª—Ç—ã", quantity: 4 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ", output: 1, time: 8, ingredients: [{ item: "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞", quantity: 1 }, { item: "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°", quantity: 1 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—É—Å–∏–ª–µ–Ω–Ω–∞—è –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –ø–ª–∏—Ç–∞", output: 1, time: 4.8, ingredients: [{ item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞", quantity: 2 }, { item: "–∫–∞–º–µ–Ω—å", quantity: 3 }], building: "–ê—Å—Å–µ–º–±–ª–µ—Ä" },
            { product: "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°", output: 1, time: 16, ingredients: [{ item: "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞", quantity: 3 }, { item: "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞", quantity: 1 }], building: "–ó–∞—Ä—è–¥–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ" },
            { product: "–∫—Ä–∞—Å–Ω–∞—è –∫–æ–ª–±–∞", output: 1, time: 4.8, ingredients: [{ item: "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞", quantity: 3 }, { item: "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫", quantity: 3 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "–∑–µ–ª–µ–Ω–∞—è –∫–æ–ª–±–∞", output: 1, time: 8, ingredients: [{ item: "—Ç–∫–∞–Ω—å", quantity: 3 }, { item: "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", quantity: 2 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "—Å–∏–Ω—è—è –∫–æ–ª–±–∞", output: 1, time: 9.6, ingredients: [{ item: "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ", quantity: 1 }, { item: "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞", quantity: 3 }], building: "–ö—Ä–∏—Å—Ç–∞–ª–∏–∑–∞—Ç–æ—Ä" },
            { product: "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ", output: 1, time: 12, ingredients: [{ item: "–∑–µ—Ä–Ω–æ", quantity: 4 }], building: "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫" },
            { product: "—Å–ø–∏—Ä—Ç–Ω—ã–µ –Ω–∞–ø–∏—Ç–∫–∏", output: 1, time: 12, ingredients: [{ item: "–∑–µ—Ä–Ω–æ", quantity: 4 }], building: "–ó–µ—Ä–Ω–æ–ø–µ—Ä–µ—Ä–∞–±–æ—Ç—á–∏–∫" }
        ];

        const recipeMap = new Map();
        recipes.forEach(r => recipeMap.set(r.product, r));
        const allProducts = recipes.map(r => r.product).sort();

        const emojiMap = {
            "–¥–µ—Ä–µ–≤–æ": "üå≥", "–∂–µ–ª–µ–∑–Ω–∞—è —Ä—É–¥–∞": "‚õèÔ∏è", "–ø—Ä–∏—Ä–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å": "ü™®", "–º–µ–¥–Ω–∞—è —Ä—É–¥–∞": "ü™®", "—É–≥–æ–ª—å": "‚ö´", "–∑–µ—Ä–Ω–æ": "üåæ",
            "–ª–µ—Å–æ–º–∞—Ç–µ—Ä–∏–∞–ª": "ü™µ", "–ø–∞–ª–∫–∏": "ü•¢", "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è —Ä–∞–º–∞": "üñºÔ∏è", "—Å–ª–∏—Ç–æ–∫ –∂–µ–ª–µ–∑–∞": "ü™ô", "–∂–µ–ª–µ–∑–Ω—ã–π —Å—Ç–µ—Ä–∂–µ–Ω—å": "üî©",
            "–±–æ–ª—Ç—ã": "‚öôÔ∏è", "–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –¥–æ—â–µ—á–∫–∞": "ü™µ", "–∫–∞–º–µ–Ω—å": "üß±", "–∫–∞–º–µ–Ω–Ω—ã–π –∫–∏—Ä–ø–∏—á": "üß±", "–∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞": "üõ°Ô∏è",
            "–º–µ–¥–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞": "ü•â", "–º–µ–¥–Ω—ã–π –∫–∞–±–µ–ª—å": "üîå", "–¥—Ä–µ–≤–µ—Å–Ω–æ–µ –≤–æ–ª–æ–∫–Ω–æ": "üåø", "–Ω–∏—Ç—å": "üßµ", "—Ç–∫–∞–Ω—å": "üëï",
            "–±—É–º–∞–≥–∞": "üìÑ", "—Å—Ç–∞–ª—å–Ω–∞—è —Ç—Ä—É–±–∞": "üîß", "—Å—Ç–∞–ª—å–Ω–∞—è –ø–ª–∞—Å—Ç–∏–Ω–∞": "üî©", "–º–µ–¥–Ω—ã–π —Å–ª–∏—Ç–æ–∫": "ü™ô", "—Å—Ç–∞–ª—å–Ω–æ–π —Å–ª–∏—Ç–æ–∫": "‚öôÔ∏è",
            "–∑–æ–Ω—Ç–∏–∫": "‚òÇÔ∏è", "–±—Ä–æ–Ω–∑–æ–≤–æ–µ –∑–µ—Ä–∫–∞–ª–æ": "ü™û", "–æ—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã": "üî®", "–ø—Ä–æ–º–∞—Å–ª–µ–Ω–∞—è –±—É–º–∞–≥–∞": "üìÉ",
            "–∂–µ–ª–µ–∑–Ω–∞—è —Ä–∞–º–∞": "üñºÔ∏è", "–∞—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∂–µ–ª–µ–∑–Ω–∞—è –ø–ª–∏—Ç–∞": "üõ°Ô∏è", "–∂–µ–ª–µ–∑–Ω–æ–µ —è–¥—Ä–æ": "‚öõÔ∏è", "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å –°": "üîã",
            "—É—Å–∏–ª–µ–Ω–Ω–∞—è –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è –ø–ª–∏—Ç–∞": "ü™µüß±", "–∫—Ä–∞—Å–Ω–∞—è –∫–æ–ª–±–∞": "üß™üî¥", "–∑–µ–ª–µ–Ω–∞—è –∫–æ–ª–±–∞": "üß™üü¢", "—Å–∏–Ω—è—è –∫–æ–ª–±–∞": "üß™üîµ",
            "–∫—É–ª–∏–Ω–∞—Ä–Ω–æ–µ –º–∞—Å–ª–æ": "ü´í", "—Å–ø–∏—Ä—Ç–Ω—ã–µ –Ω–∞–ø–∏—Ç–∫–∏": "üç∫"
        };

        const selectEl = document.getElementById('product');
        allProducts.forEach(prod => {
            const option = document.createElement('option');
            option.value = prod;
            option.textContent = prod;
            selectEl.appendChild(option);
        });
        selectEl.value = "—Å–∏–Ω—è—è –∫–æ–ª–±–∞";

        const modeToggle = document.getElementById('modeToggle');
        const modePerMinuteLabel = document.getElementById('modePerMinuteLabel');
        const modePerDayLabel = document.getElementById('modePerDayLabel');
        const perMinuteField = document.getElementById('perMinuteField');
        const perDayField = document.getElementById('perDayField');
        const dayLengthInput = document.getElementById('dayLength');
        const ratePerMinute = document.getElementById('ratePerMinute');
        const ratePerDay = document.getElementById('ratePerDay');

        let currentDayLength = parseFloat(dayLengthInput.value);

        function updateMode() {
            const isDayMode = modeToggle.checked;
            if (isDayMode) {
                modePerMinuteLabel.classList.remove('active');
                modePerDayLabel.classList.add('active');
                perMinuteField.classList.add('hidden');
                perDayField.classList.remove('hidden');
            } else {
                modePerMinuteLabel.classList.add('active');
                modePerDayLabel.classList.remove('active');
                perMinuteField.classList.remove('hidden');
                perDayField.classList.add('hidden');
            }
        }

        modeToggle.addEventListener('change', updateMode);
        dayLengthInput.addEventListener('input', function() {
            let val = parseFloat(this.value);
            if (isNaN(val)) val = 16;
            if (val < 13) val = 13;
            if (val > 30) val = 30;
            this.value = val;
            currentDayLength = val;
        });

        updateMode();

        function calculate(targetProduct, targetRate) {
            const demands = {};
            demands[targetProduct] = targetRate;

            const edgesMap = {};

            const queue = [targetProduct];
            const inQueue = new Set([targetProduct]);
            const processed = new Set();

            while (queue.length > 0) {
                const product = queue.shift();
                inQueue.delete(product);

                if (!recipeMap.has(product)) {
                    continue;
                }

                const recipe = recipeMap.get(product);
                const outputPerCycle = recipe.output;
                const rate = demands[product];
                const cyclesPerMin = rate / outputPerCycle;

                for (const ing of recipe.ingredients) {
                    const required = cyclesPerMin * ing.quantity;
                    if (required <= 0) continue;

                    const key = `${ing.item}|${product}`;
                    edgesMap[key] = (edgesMap[key] || 0) + required;

                    const oldDemand = demands[ing.item] || 0;
                    demands[ing.item] = oldDemand + required;

                    if (recipeMap.has(ing.item)) {
                        if (oldDemand === 0 || processed.has(ing.item)) {
                            if (!inQueue.has(ing.item)) {
                                inQueue.add(ing.item);
                                queue.push(ing.item);
                            }
                        }
                    }
                }

                processed.add(product);
            }

            const edges = Object.entries(edgesMap).map(([key, quantity]) => {
                const [from, to] = key.split('|');
                return { from, to, quantity };
            });

            const machines = {};
            const primary = {};

            for (const [prod, rate] of Object.entries(demands)) {
                if (recipeMap.has(prod)) {
                    const recipe = recipeMap.get(prod);
                    const cyclesPerMin = rate / recipe.output;
                    const timeMin = recipe.time / 60;
                    machines[prod] = cyclesPerMin * timeMin;
                } else {
                    primary[prod] = rate;
                }
            }

            return { demands, machines, primary, edges };
        }

        let graphNodes = [];
        let graphEdges = [];
        let graphMachines = {};
        let demandsForGraph = {};

        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;

        let draggedNodeIndex = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let isDraggingBg = false;
        let lastMouseX = 0, lastMouseY = 0;

        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('graph-container');

        canvas.width = 2000;
        canvas.height = 2000;

        function canvasToWorld(canvasX, canvasY) {
            return {
                x: (canvasX - offsetX) / scale,
                y: (canvasY - offsetY) / scale
            };
        }

        function splitTitle(nodeId) {
            const emoji = emojiMap[nodeId] || 'üì¶';
            const fullText = emoji + ' ' + nodeId;
            const maxChars = 18;

            const words = fullText.split(' ');
            const lines = [];
            let currentLine = '';

            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                let testLength = 0;
                for (let char of testLine) {
                    if (char.match(/\p{Emoji}/u)) {
                        testLength += 2;
                    } else {
                        testLength += 1;
                    }
                }
                if (testLength <= maxChars) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);

            if (lines.length === 0) lines.push(fullText);

            // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å 10 –ø–∏–∫—Å–µ–ª–µ–π —Å–Ω–∏–∑—É, —á—Ç–æ–±—ã –∑–µ–ª—ë–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –Ω–µ –≤—ã–ª–µ–∑–∞–ª–∞
            const height = 70 + (lines.length - 1) * 18 + 10;
            return { lines, height };
        }

        function generateInitialPositions(demands, edges) {
            const nodeList = Object.keys(demands).sort();

            const level = {};
            const computed = new Set();

            function computeLevel(node) {
                if (computed.has(node)) return level[node];
                if (!recipeMap.has(node)) {
                    level[node] = 0;
                    computed.add(node);
                    return 0;
                }
                const recipe = recipeMap.get(node);
                let maxIngLevel = -1;
                for (const ing of recipe.ingredients) {
                    if (demands[ing.item] !== undefined) {
                        const ingLevel = computeLevel(ing.item);
                        if (ingLevel > maxIngLevel) maxIngLevel = ingLevel;
                    }
                }
                if (maxIngLevel === -1) maxIngLevel = 0;
                level[node] = maxIngLevel + 1;
                computed.add(node);
                return level[node];
            }

            nodeList.forEach(node => computeLevel(node));

            const levels = {};
            nodeList.forEach(node => {
                const lvl = level[node];
                if (!levels[lvl]) levels[lvl] = [];
                levels[lvl].push(node);
            });

            const nodes = [];
            const marginX = 250;
            const marginY = 120;
            const startX = 150;
            const canvasHeight = canvas.height;
            for (const lvl in levels) {
                const nodesAtLevel = levels[lvl];
                const count = nodesAtLevel.length;
                const totalHeight = (count - 1) * marginY;
                const startYLevel = (canvasHeight / 2) - (totalHeight / 2);
                nodesAtLevel.forEach((node, idx) => {
                    const verticalOffset = (idx % 3 - 1) * 30;
                    const { lines, height } = splitTitle(node);
                    nodes.push({
                        id: node,
                        x: startX + parseInt(lvl) * marginX,
                        y: startYLevel + idx * marginY + verticalOffset,
                        width: 160,
                        height: height,
                        lines: lines
                    });
                });
            }
            return nodes;
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2 / scale;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            graphEdges.forEach(edge => {
                const fromNode = graphNodes.find(n => n.id === edge.from);
                const toNode = graphNodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                const fromX = fromNode.x + fromNode.width/2;
                const fromY = fromNode.y + fromNode.height/2;
                const toX = toNode.x + toNode.width/2;
                const toY = toNode.y + toNode.height/2;

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#7f8c8d';
                ctx.stroke();

                let label = edge.quantity.toFixed(2);
                const fromMachines = graphMachines[edge.from];
                const fromDemand = demandsForGraph[edge.from];
                if (fromMachines !== undefined && fromDemand > 0) {
                    const allocatedMachines = fromMachines * (edge.quantity / fromDemand);
                    label += ` (üõ†Ô∏è ${allocatedMachines.toFixed(2)})`;
                }

                const midX = (fromX + toX) / 2;
                const midY = (fromY + toY) / 2;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(midX - 40, midY - 10, 80, 20);
                ctx.fillStyle = '#2c3e50';
                ctx.fillText(label, midX, midY);
            });

            graphNodes.forEach(node => {
                ctx.fillStyle = '#3498db';
                ctx.shadowColor = '#2c3e50';
                ctx.shadowBlur = 5 / scale;
                ctx.beginPath();
                ctx.roundRect(node.x, node.y, node.width, node.height, 20);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const lines = node.lines;
                const lineHeight = 18;
                const startY = node.y + node.height/2 - (lines.length-1)*lineHeight/2 - 8;
                for (let i = 0; i < lines.length; i++) {
                    ctx.fillText(lines[i], node.x + node.width/2, startY + i * lineHeight);
                }

                const rate = demandsForGraph[node.id];
                const machinesCount = graphMachines[node.id];
                if (rate !== undefined) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#f1c40f';
                    let yOffset = node.y + node.height/2 + 12;
                    if (lines.length > 1) yOffset += 4;
                    ctx.fillText(rate.toFixed(2) + '/min', node.x + node.width/2, yOffset);
                    if (machinesCount !== undefined) {
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillText('üõ†Ô∏è ' + machinesCount.toFixed(2), node.x + node.width/2, yOffset + 18);
                    }
                }
            });

            ctx.restore();
        }

        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            this.closePath();
            return this;
        };

        function updateGraph(edges, demands, machines) {
            demandsForGraph = demands;
            graphMachines = machines;
            graphEdges = edges;
            graphNodes = generateInitialPositions(demands, edges);
            drawGraph();
        }

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseCanvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseCanvasY = (e.clientY - rect.top) * (canvas.height / rect.height);

            const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.min(Math.max(scale * delta, 0.1), 3);

            offsetX = mouseCanvasX - worldPos.x * newScale;
            offsetY = mouseCanvasY - worldPos.y * newScale;

            scale = newScale;
            drawGraph();
        });

        container.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseCanvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseCanvasY = (e.clientY - rect.top) * (canvas.height / rect.height);

            let hitNode = false;
            for (let i = 0; i < graphNodes.length; i++) {
                const node = graphNodes[i];
                const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);
                if (worldPos.x >= node.x && worldPos.x <= node.x + node.width &&
                    worldPos.y >= node.y && worldPos.y <= node.y + node.height) {
                    hitNode = true;
                    draggedNodeIndex = i;
                    dragOffsetX = worldPos.x - node.x;
                    dragOffsetY = worldPos.y - node.y;
                    break;
                }
            }

            if (!hitNode) {
                isDraggingBg = true;
                lastMouseX = mouseCanvasX;
                lastMouseY = mouseCanvasY;
                container.classList.add('dragging-bg');
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (draggedNodeIndex !== null) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseCanvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseCanvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
                const worldPos = canvasToWorld(mouseCanvasX, mouseCanvasY);

                const node = graphNodes[draggedNodeIndex];
                node.x = worldPos.x - dragOffsetX;
                node.y = worldPos.y - dragOffsetY;

                node.x = Math.max(0, Math.min(canvas.width - node.width, node.x));
                node.y = Math.max(0, Math.min(canvas.height - node.height, node.y));

                drawGraph();
            } else if (isDraggingBg) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseCanvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseCanvasY = (e.clientY - rect.top) * (canvas.height / rect.height);

                const dx = mouseCanvasX - lastMouseX;
                const dy = mouseCanvasY - lastMouseY;

                offsetX += dx;
                offsetY += dy;

                lastMouseX = mouseCanvasX;
                lastMouseY = mouseCanvasY;

                drawGraph();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (draggedNodeIndex !== null) {
                draggedNodeIndex = null;
            }
            if (isDraggingBg) {
                isDraggingBg = false;
                container.classList.remove('dragging-bg');
            }
        });

        document.getElementById('reset-graph').addEventListener('click', () => {
            if (Object.keys(demandsForGraph).length > 0) {
                graphNodes = generateInitialPositions(demandsForGraph, graphEdges);
                drawGraph();
            }
        });

        document.getElementById('reset-view').addEventListener('click', () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            drawGraph();
        });

        function displayResults(targetProduct, targetRate, modeDescription) {
            const result = calculate(targetProduct, targetRate);
            const { demands, machines, primary, edges } = result;

            const allProducts = Object.keys(demands).sort((a, b) => {
                const aIsPrimary = !recipeMap.has(a);
                const bIsPrimary = !recipeMap.has(b);
                if (aIsPrimary && !bIsPrimary) return 1;
                if (!aIsPrimary && bIsPrimary) return -1;
                return 0;
            });

            let html = `<div class="day-info">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—É—Ç–æ–∫: ${currentDayLength} –º–∏–Ω</div>`;
            html += `<p><strong>–†–µ–∂–∏–º:</strong> ${modeDescription}</p>`;
            html += `<table>
                <tr>
                    <th>–ü—Ä–æ–¥—É–∫—Ç</th>
                    <th>–ò–∫–æ–Ω–∫–∞</th>
                    <th>–í –º–∏–Ω—É—Ç—É</th>
                    <th>–ó–∞ —Å—É—Ç–∫–∏</th>
                    <th>–ú–∞—à–∏–Ω</th>
                    <th>–≠–Ω–µ—Ä–≥–∏—è (–∫–í—Ç)</th>
                    <th>–ó–¥–∞–Ω–∏–µ</th>
                </tr>`;

            let totalEnergy = 0;

            for (const prod of allProducts) {
                const rate = demands[prod];
                const perDay = rate * currentDayLength;
                const emoji = emojiMap[prod] || 'üì¶';
                const isPrimary = !recipeMap.has(prod);
                const rowClass = isPrimary ? 'primary' : 'intermediate';

                let machineCell = '';
                let energyCell = '';
                let buildingCell = '';
                if (!isPrimary) {
                    const recipe = recipeMap.get(prod);
                    const machineCount = machines[prod];
                    const machineCountFixed = machineCount.toFixed(3);
                    const building = recipe.building;
                    const power = buildingPower[building] || 0;
                    const energy = machineCount * power;
                    totalEnergy += energy;
                    machineCell = machineCountFixed;
                    energyCell = energy.toFixed(2) + ' –∫–í—Ç';
                    buildingCell = building;
                } else {
                    machineCell = '‚Äî';
                    energyCell = '‚Äî';
                    buildingCell = '‚Äî';
                }

                html += `<tr class="${rowClass}">
                    <td>${prod}</td>
                    <td><span class="emoji">${emoji}</span></td>
                    <td>${rate.toFixed(2)}</td>
                    <td>${perDay.toFixed(2)}</td>
                    <td>${machineCell}</td>
                    <td>${energyCell}</td>
                    <td>${buildingCell}</td>
                </tr>`;
            }

            html += `<tr class="total-row">
                <td colspan="5" style="text-align: right;"><strong>–ò—Ç–æ–≥–æ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ:</strong></td>
                <td><strong>${totalEnergy.toFixed(2)} –∫–í—Ç</strong></td>
                <td></td>
            </tr>`;
            html += `</table>`;
            html += `<p class="note">* –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∞—à–∏–Ω –∏ —ç–Ω–µ—Ä–≥–æ–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ —É–∫–∞–∑–∞–Ω—ã –≤ –¥–æ–ª—è—Ö (–¥–ª—è –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã). –î–ª—è –ø–æ—Å—Ç—Ä–æ–π–∫–∏ –æ–∫—Ä—É–≥–ª–∏—Ç–µ –≤–≤–µ—Ä—Ö.</p>`;

            document.getElementById('output').innerHTML = html;

            updateGraph(edges, demands, machines);
        }

        document.getElementById('calculate').addEventListener('click', () => {
            const product = document.getElementById('product').value;
            const isDayMode = modeToggle.checked;

            let rate;
            let modeDescription;

            if (!isDayMode) {
                rate = parseFloat(ratePerMinute.value);
                if (isNaN(rate) || rate <= 0) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –º–∏–Ω—É—Ç—É.');
                    return;
                }
                modeDescription = `–≤ –º–∏–Ω—É—Ç—É: ${rate} —à—Ç/–º–∏–Ω`;
            } else {
                const amountPerDay = parseFloat(ratePerDay.value);
                if (isNaN(amountPerDay) || amountPerDay <= 0) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞ —Å—É—Ç–∫–∏.');
                    return;
                }
                rate = amountPerDay / currentDayLength;
                modeDescription = `–∑–∞ —Å—É—Ç–∫–∏ (${currentDayLength} –º–∏–Ω): ${amountPerDay} —à—Ç ‚Üí ${rate.toFixed(2)} —à—Ç/–º–∏–Ω`;
            }

            displayResults(product, rate, modeDescription);
        });

        window.onload = () => {
            displayResults('—Å–∏–Ω—è—è –∫–æ–ª–±–∞', 1, '–≤ –º–∏–Ω—É—Ç—É: 1 —à—Ç/–º–∏–Ω');
        };
    </script>
</body>
</html>